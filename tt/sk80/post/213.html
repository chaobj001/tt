<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="generator" content="blog.sk80.com" /><meta name="keywords" content="PHP缓存技术：memcache函数详解之二:PHP,memcache " /><meta name="description" content="PHP缓存技术：memcache函数详解之二,Memcached 集群架构方面的问题,PHP缓存技术：memcache函数详解之一" /><meta name="author" content="4kychao" /><link rel="stylesheet" type="text/css" href="http://sk2.com/templates/default/style.css" /><title>PHP缓存技术：memcache函数详解之二</title></head><body><div id="wrapper"><div id="header"><div id="header-inner"><p class="sitename">blog.sk80.com</p><div class="description">等我有钱了, 咱买棒棒糖, 买2 根, 1 根 你看着我吃, 另1根 我吃给你看。</div><div class="menu"><ul><li class="current_page"><a rel="nofollow" href="/">日志</a></li><!--li><a href="#">About</a></li--></ul></div></div></div><div id="wrapper-inner"><p id="topic-path"><a href="/" rel="nofollow">Home</a>&gt;<a href="http://sk2.com/category/php/">PHP</a>&gt;<strong class="current">PHP缓存技术：memcache函数详解之二</strong></p><ul id="flip1" class="flip"><li class="newer"><a title="Memcached 集群架构方面的问题" href="http://sk2.com/post/214.html" rel="nofollow">Newer</a></li><li class="older"><a title="PHP缓存技术：memcache函数详解之一" href="http://sk2.com/post/212.html" rel="nofollow">Older</a></li></ul><div id="detail"><div class="post"><h1>PHP缓存技术：memcache函数详解之二</h1><ul class="info"><li class="date">2010年 04月10日  18:12</li><li class="category"><a href="http://sk2.com/category/php/">PHP</a></li></ul><div class="textbody"><p><strong>memcache::debug</strong></p><p align="left">bool <strong>memcache_debug</strong> ( bool <em>$on_off</em> )</p><p></p><p><strong>说明：</strong></p><p>控制调试功能，前提是php在编译的时候使用了-enable-debug选项，否则这个函数不会有作用。</p><p></p><p><strong>参数：</strong></p><p>$on_off：true表示开启调试，false表示关闭调试</p><p></p><p><strong>返回值：</strong></p><p>如果php在编译的时候使用了-enable-debug选项，返回true，否则返回false</p><p></p><p></p><p><strong>Memcache::decrement用法</strong></p><p align="left">int <strong>Memcache::decrement</strong> ( string <em>$key</em> [, int <em>$value</em> ] )</p><p></p><p><strong>说明：</strong></p><p>Memcache::decremen方法的作用是对保存的某个key中的值进行减法操作，用法跟Memcache::increment类似。</p><p>你也可以用memcache_decrement()函数。</p><p></p><p><strong>参数：</strong></p><p>Key:想要减少的键的名字</p><p>Value:想要减少的值。</p><p></p><p><strong>返回值：</strong></p><p>如果成功，返回被减少后的值，如果失败返回false。</p><p></p><p><strong>例子：</strong></p><p>&lt;?php</p><p>$memcache = new Memcache;</p><p>$memcache-&gt;connect(‘localhost’, 11211);</p><p>$memcache-&gt;set(‘test_item’, 8);</p><p>$memcache-&gt;increment(‘test_item’, 4);</p><p>echo $memcache-&gt;decrement(‘test_item’, 7);</p><p>// 显示 5</p><p>?&gt;</p><p>这个例子连Memcache::increment函数都一块演示了。</p><p></p><p><strong>Memcache::delete用法</strong></p><p align="left">bool <strong>Memcache::delete</strong> ( string <em>$key</em> [, int <em>$timeout</em> ] )</p><p></p><p><strong>说明：</strong></p><p>删除一个key值，如果参数$timeout被设置，那么存储的值会在设置的秒数以后过期，你也可以用函数memcache_delete()</p><p></p><p><strong>返回值：</strong></p><p>如果成功则返回 TRUE，失败则返回 FALSE。</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);</p><p>/*&nbsp;在10秒以后，缓存的值会被服务器删除&nbsp;*/<br />memcache_delete($memcache_obj,&nbsp;’key_to_delete’,&nbsp;10);</p><p>/*&nbsp;面向对象&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache_obj-&gt;connect(‘memcache_host’,&nbsp;11211);</p><p>$memcache_obj-&gt;delete(‘key_to_delete’,&nbsp;10);</p><p>?&gt;</p><p></p><p></p><p><strong>Memcache::flush</strong></p><p align="left">bool <strong>Memcache::flush</strong> ( void )</p><p></p><p><strong>说明：</strong></p><p>清除所有缓存的数据。Memcache::flush实际上没有释放资源，它仅仅将所有的缓存标记为过期，这样可以使新的缓存来覆盖被占的内存空间。一样的函数是memcache_flush()</p><p></p><p><strong>返回值：</strong></p><p>如果成功则返回 TRUE，失败则返回 FALSE。</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);</p><p>memcache_flush($memcache_obj);</p><p>/*&nbsp;面向对象&nbsp;API&nbsp;*/</p><p>$memcache_obj&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache_obj-&gt;connect(‘memcache_host’,&nbsp;11211);</p><p>$memcache_obj-&gt;flush();</p><p>?&gt;</p><p></p><p></p><p><strong>Memcache::get</strong></p><p align="left">string <strong>Memcache::get</strong> ( string <em>$key</em> [, int <em>&amp;$flags</em> ] )</p><p align="left">array <strong>Memcache::get</strong> ( array <em>$keys</em> [, array <em>&amp;$flags</em> ] )</p><p></p><p><strong>说明：</strong></p><p>方法的作用是获取一个key值，key值可以是一个数组，结果会包含键值对。</p><p></p><p><strong>参数：</strong></p><p>$key是键值或者一个键的数组值。</p><p>$flags如果这个参数存在，那么$flags跟写入这个参数的值相关，这些$flags 类似于Memcache::set()函数里的$flags。</p><p></p><p><strong>返回值：</strong></p><p>如果成功，则返回key对应的值，如果失败则返回false.</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);<br />$var&nbsp;=&nbsp;memcache_get($memcache_obj,&nbsp;’some_key’);</p><p>/*&nbsp;面向对象&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache_obj-&gt;connect(‘memcache_host’,&nbsp;11211);<br />$var&nbsp;=&nbsp;$memcache_obj-&gt;get(’some_key’);</p><p>/*�<br />你可以使用数组键作为参数，如果值没有在服务器中找到，那么结果数组不会包含该键<br />*/</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);<br />$var&nbsp;=&nbsp;memcache_get($memcache_obj,&nbsp;Array(’some_key’,&nbsp;’another_key’));</p><p>/*&nbsp;面向对象&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache_obj-&gt;connect(‘memcache_host’,&nbsp;11211);<br />$var&nbsp;=&nbsp;$memcache_obj-&gt;get(Array(’some_key’,&nbsp;’second_key’));</p><p>?&gt;</p><p></p><p><strong>Memcache::getExtendedStats</strong></p><p>array <strong>Memcache::getExtendedStats</strong> ([ string <tt><em>$type</em></tt> [, int <tt><em>$slabid</em></tt> [, int <tt><em>$limit</em></tt> ]]] )</p><p></p><p><strong>说明：</strong></p><p>获取进程池中所有进程的运行系统统计。相同函数是<strong>memcache_get_extended_stats()</strong></p><p></p><p><strong>参数：</strong></p><p>$type表示要求返回的类型：reset, malloc, maps, cachedump, slabs, items, sizes;</p><p>$slabid第一个参数设置为”cachedump”时使用的。</p><p>$limit第一个参数设置为”cachedump”时使用的。</p><p><tt>&nbsp;</tt></p><p><strong>返回值：</strong></p><p>如果成功，返回统计信息，失败会返回false</p><p><tt>&nbsp;</tt></p><p><strong>例子：</strong></p><p align="left">&lt;?php<br />$memcache_obj&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache_obj-&gt;addServer(‘memcache_host’,&nbsp;11211);<br />$memcache_obj-&gt;addServer(‘failed_host’,&nbsp;11211);</p><p>$stats&nbsp;=&nbsp;$memcache_obj-&gt;getExtendedStats();</p><p align="left">&nbsp;&nbsp; //slabs机制分配管理内存的情况</p><p align="left">$statsslab = $memcache_obj-&gt;getExtendedStats(slabs);</p><p>?&gt;</p><p></p><p></p><p><strong>Memcache::getServerStatus</strong></p><p align="left">int <strong>Memcache::getServerStatus</strong> ( string <em>$host</em> [, int <em>$port</em> ] )</p><p></p><p><strong>说明：</strong></p><p>获取运行服务器的参数。返回一个服务器在线或者离线的状态。相同的函数是memcache_get_server_status()</p><p></p><p><strong>参数：</strong></p><p>$host：正在收听的连接的主机</p><p>$port正在收听的连接的主机的端口，默认是11211</p><p></p><p><strong>返回值：</strong></p><p>成功返回服务器状态，服务器没有启动会返回0，其他数字的时候表示服务器是启动状态的。</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>/*&nbsp;面向对象&nbsp;API&nbsp;*/<br />$memcache&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache-&gt;addServer(‘memcache_host’,&nbsp;11211);<br />echo&nbsp;$memcache-&gt;getServerStatus(‘memcache_host’,&nbsp;11211);</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/<br />$memcache&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);<br />echo&nbsp;memcache_get_server_status($memcache,&nbsp;’memcache_host’,&nbsp;11211);</p><p>?&gt;</p><p></p><p></p><p><strong>Memcache::getStats</strong></p><p align="left">array <strong>Memcache::getStats</strong> ([ string <em>$type</em> [, int <em>$slabid</em> [, int <em>$limit</em> ]]] )</p><p></p><p><strong>说明：</strong></p><p>返回服务器的一些运行统计信息。相同的函数是memcache_get_stats()</p><p></p><p><strong>参数：</strong></p><p>$type表示要求返回的类型：reset, malloc, maps, cachedump, slabs, items, sizes;</p><p>$slabid第一个参数设置为”cachedump”时使用的。</p><p>$limit第一个参数设置为”cachedump”时使用的。</p></div><div class="entry-tags"><strong>Tags:</strong><a href="http://sk2.com/tag/memcache/">memcache</a></div></div><ul id="flip2" class="flip"><li>Newer:<a href="http://sk2.com/post/214.html">Memcached 集群架构方面的问题</a></li><li>Older:<a href="http://sk2.com/post/212.html">PHP缓存技术：memcache函数详解之一</a></li></ul></div>
<div id="footer"><div><a rel="nofollow" class="admin" href="http://sk2.com/login"><small>ADMIN</small></a><address>&copy; 2010 <a href='http://sk2.com/'>blog.sk80.com</a></address></div></div></div></div><script type="text/javascript" src="http://sk2.com/include/js/resize.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">try {var pageTracker = _gat._getTracker("UA-5695529-2");pageTracker._trackPageview();} catch(err) {}</script></body></html>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/3688801.js"></script>
<noscript><a href="http://www.51.la/?3688801" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/3688801.asp" style="border:none" /></a></noscript>