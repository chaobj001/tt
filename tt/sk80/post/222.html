<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="generator" content="blog.sk80.com" /><meta name="keywords" content="MySQL Explain 详解:Mysql," /><meta name="description" content="MySQL Explain 详解,表单过期的处理（提交出错后返回，保存原来数据),jQuery性能优化指南" /><meta name="author" content="4kychao" /><link rel="stylesheet" type="text/css" href="http://sk2.com/templates/default/style.css" /><title>MySQL Explain 详解</title></head><body><div id="wrapper"><div id="header"><div id="header-inner"><p class="sitename">blog.sk80.com</p><div class="description">等我有钱了, 咱买棒棒糖, 买2 根, 1 根 你看着我吃, 另1根 我吃给你看。</div><div class="menu"><ul><li class="current_page"><a rel="nofollow" href="/">日志</a></li><!--li><a href="#">About</a></li--></ul></div></div></div><div id="wrapper-inner"><p id="topic-path"><a href="/" rel="nofollow">Home</a>&gt;<a href="http://sk2.com/category/mysql/">Mysql</a>&gt;<strong class="current">MySQL Explain 详解</strong></p><ul id="flip1" class="flip"><li class="newer"><a title="表单过期的处理（提交出错后返回，保存原来数据)" href="http://sk2.com/post/223.html" rel="nofollow">Newer</a></li><li class="older"><a title="jQuery性能优化指南" href="http://sk2.com/post/221.html" rel="nofollow">Older</a></li></ul><div id="detail"><div class="post"><h1>MySQL Explain 详解</h1><ul class="info"><li class="date">2010年 04月10日  18:26</li><li class="category"><a href="http://sk2.com/category/mysql/">Mysql</a></li></ul><div class="textbody"><p>　　<strong>一.语法</strong></p><p>　　explain &lt; table_name &gt;</p><p>　　例如: explain select * from t3 where id=3952602;</p><p>　　<strong>二.explain输出解释</strong></p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br />　　1.id</td></tr></tbody></table><p>　<strong>　<span id="more-357"></span>1.我的理解是SQL执行的顺利的标识,SQL从大到小的执行.</strong></p><p>　　例如:</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;(select&nbsp;*&nbsp;from&nbsp;(&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602)&nbsp;a)&nbsp;b;<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;|&nbsp;system&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;DERIVED&nbsp;|&nbsp;|&nbsp;system&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;3&nbsp;|&nbsp;DERIVED&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+</td></tr></tbody></table><p>　　很显然这条SQL是从里向外的执行,就是从id=3 向上执行.</p><p>　<strong>　2. select_type就是select类型,可以有以下几种</strong></p><p>　　(1) SIMPLE</p><p>　　简单SELECT(不使用UNION或子查询等) 例如:　</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602;<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;const&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+</td></tr></tbody></table><p>　　(2). PRIMARY</p><p>　　我的理解是最外层的select.例如:</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;(select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602)&nbsp;a&nbsp;;<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;|&nbsp;system&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;DERIVED&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+</td></tr></tbody></table><p>(3).UNION</p><p>　　UNION中的第二个或后面的SELECT语句.例如</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602&nbsp;union&nbsp;all&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;;<br />　　+—-+————–+————+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————–+————+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;const&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;UNION&nbsp;|&nbsp;t3&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1000&nbsp;|&nbsp;|<br />　　|NULL&nbsp;|&nbsp;UNION&nbsp;RESULT&nbsp;|&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;|<br />　　+—-+————–+————+——-+——————-+———+———+——-+——+——-+</td></tr></tbody></table><p>　　(4).DEPENDENT UNION</p><p>　　UNION中的第二个或后面的SELECT语句，取决于外面的查询</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id&nbsp;in&nbsp;(select&nbsp;id&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602&nbsp;union&nbsp;all&nbsp;select&nbsp;id&nbsp;from&nbsp;t3)&nbsp;;<br />　　+—-+——————–+————+——–+——————-+———+———+——-+——+————————–+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+——————–+————+——–+——————-+———+———+——-+——+————————–+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;t3&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1000&nbsp;|&nbsp;Using&nbsp;where&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;DEPENDENT&nbsp;SUBQUERY&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;const&nbsp;|&nbsp;1&nbsp;|&nbsp;Using&nbsp;index&nbsp;|<br />　　|&nbsp;3&nbsp;|&nbsp;DEPENDENT&nbsp;UNION&nbsp;|&nbsp;t3&nbsp;|&nbsp;eq_ref&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;func&nbsp;|&nbsp;1&nbsp;|&nbsp;Using&nbsp;where;&nbsp;Using&nbsp;index&nbsp;|<br />　　|NULL&nbsp;|&nbsp;UNION&nbsp;RESULT&nbsp;|&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;|<br />　　+—-+——————–+————+——–+——————-+———+———+——-+——+————————–+</td></tr></tbody></table><p>　　(5).UNION RESULT</p><p>　　UNION的结果。</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602&nbsp;union&nbsp;all&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;;<br />　　+—-+————–+————+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————–+————+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;const&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;UNION&nbsp;|&nbsp;t3&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1000&nbsp;|&nbsp;|<br />　　|NULL&nbsp;|&nbsp;UNION&nbsp;RESULT&nbsp;|&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;|<br />　　+—-+————–+————+——-+——————-+———+———+——-+——+——-+</td></tr></tbody></table><p>　　(6).SUBQUERY</p><p>　　子查询中的第一个SELECT.</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id&nbsp;=&nbsp;(select&nbsp;id&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602&nbsp;)&nbsp;;<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+————-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+————-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;const&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;SUBQUERY&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;|&nbsp;1&nbsp;|&nbsp;Using&nbsp;index&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+————-+</td></tr></tbody></table><p>(7). DEPENDENT SUBQUERY</p><p>　　子查询中的第一个SELECT，取决于外面的查询</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;id&nbsp;from&nbsp;t3&nbsp;where&nbsp;id&nbsp;in&nbsp;(select&nbsp;id&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602&nbsp;)&nbsp;;<br />　　+—-+——————–+——-+——-+——————-+———+———+——-+——+————————–+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+——————–+——-+——-+——————-+———+———+——-+——+————————–+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;t3&nbsp;|&nbsp;index&nbsp;|&nbsp;NULL&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1000&nbsp;|&nbsp;Using&nbsp;where;&nbsp;Using&nbsp;index&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;DEPENDENT&nbsp;SUBQUERY&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;const&nbsp;|&nbsp;1&nbsp;|&nbsp;Using&nbsp;index&nbsp;|<br />　　+—-+——————–+——-+——-+——————-+———+———+——-+——+————————–+</td></tr></tbody></table><p>　　(8).DERIVED</p><p>　　派生表的SELECT(FROM子句的子查询)　</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;(select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602)&nbsp;a&nbsp;;<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;|&nbsp;system&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;DERIVED&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+</td></tr></tbody></table><p>　<strong>　3.table</strong></p><p>　　显示这一行的数据是关于哪张表的.</p><p>　　有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)　</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;(select&nbsp;*&nbsp;from&nbsp;(&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602)&nbsp;a)&nbsp;b;<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;|&nbsp;system&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;DERIVED&nbsp;|&nbsp;|&nbsp;system&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;3&nbsp;|&nbsp;DERIVED&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+</td></tr></tbody></table><p>　<strong>　4.type</strong></p><p>　　这列很重要,显示了连接使用了哪种类别,有无使用索引.</p><p>　　从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL</p><p>　　(1).system</p><p>　　这是const联接类型的一个特例。表仅有一行满足条件.如下(t3表上的id是 primary key)</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;(select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602)&nbsp;a&nbsp;;<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;|&nbsp;system&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　|&nbsp;2&nbsp;|&nbsp;DERIVED&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+————+——–+——————-+———+———+——+——+——-+</td></tr></tbody></table><p>　(2).const</p><p>　　表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次!</p><p>　　const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。在下面的查询中，tbl_name可以用于const表：</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">SELECT&nbsp;*&nbsp;from&nbsp;tbl_name&nbsp;WHERE&nbsp;primary_key=1;<br />SELECT&nbsp;*&nbsp;from&nbsp;tbl_name&nbsp;WHERE&nbsp;primary_key_part1=1和&nbsp;primary_key_part2=2;</td></tr></tbody></table><p>　　例如:</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602;<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t3&nbsp;|&nbsp;const&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;PRIMARY&nbsp;|&nbsp;4&nbsp;|&nbsp;const&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———+———+——-+——+——-+</td></tr></tbody></table><p>　　(3). eq_ref</p><p>　　对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。</p><p>　　eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。</p><p>　　在下面的例子中，MySQL可以使用eq_ref联接来处理ref_tables：</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">SELECT&nbsp;*&nbsp;FROM&nbsp;ref_table,other_table<br />　　WHERE&nbsp;ref_table.key_column=other_table.column;<br />　　SELECT&nbsp;*&nbsp;FROM&nbsp;ref_table,other_table<br />　　WHERE&nbsp;ref_table.key_column_part1=other_table.column<br />　　AND&nbsp;ref_table.key_column_part2=1;<br />　　</td></tr></tbody></table><p>　　例如</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;create&nbsp;unique&nbsp;index&nbsp;idx_t3_id&nbsp;on&nbsp;t3(id)&nbsp;;<br />　　Query&nbsp;OK,&nbsp;1000&nbsp;rows&nbsp;affected&nbsp;(0.03&nbsp;sec)<br />　　Records:&nbsp;1000&nbsp;Duplicates:&nbsp;0&nbsp;Warnings:&nbsp;0<br />　　mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3,t4&nbsp;where&nbsp;t3.id=t4.accountid;<br />　　+—-+————-+——-+——–+——————-+———–+———+———————-+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+——–+——————-+———–+———+———————-+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t4&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1000&nbsp;|&nbsp;|<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t3&nbsp;|&nbsp;eq_ref&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;idx_t3_id&nbsp;|&nbsp;4&nbsp;|&nbsp;dbatest.t4.accountid&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+——-+——–+——————-+———–+———+———————-+——+——-+</td></tr></tbody></table><p>　　(4).ref</p><p>　　对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY(换句话说，如果联接不能基于关键字选择单个行的话)，则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。</p><p>　　ref可以用于使用=或&lt;=&gt;操作符的带索引的列。</p><p>　　在下面的例子中，MySQL可以使用ref联接来处理ref_tables：</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">SELECT&nbsp;*&nbsp;FROM&nbsp;ref_table&nbsp;WHERE&nbsp;key_column=expr;<br />SELECT&nbsp;*&nbsp;FROM&nbsp;ref_table,other_table<br />WHERE&nbsp;ref_table.key_column=other_table.column;<br />SELECT&nbsp;*&nbsp;FROM&nbsp;ref_table,other_table<br />WHERE&nbsp;ref_table.key_column_part1=other_table.column<br />AND&nbsp;ref_table.key_column_part2=1;</td></tr></tbody></table><p>　例如:</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;drop&nbsp;index&nbsp;idx_t3_id&nbsp;on&nbsp;t3;<br />　　Query&nbsp;OK,&nbsp;1000&nbsp;rows&nbsp;affected&nbsp;(0.03&nbsp;sec)<br />　　Records:&nbsp;1000&nbsp;Duplicates:&nbsp;0&nbsp;Warnings:&nbsp;0<br />　　mysql&gt;&nbsp;create&nbsp;index&nbsp;idx_t3_id&nbsp;on&nbsp;t3(id)&nbsp;;<br />　　Query&nbsp;OK,&nbsp;1000&nbsp;rows&nbsp;affected&nbsp;(0.04&nbsp;sec)<br />　　Records:&nbsp;1000&nbsp;Duplicates:&nbsp;0&nbsp;Warnings:&nbsp;0<br />　　mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3,t4&nbsp;where&nbsp;t3.id=t4.accountid;<br />　　+—-+————-+——-+——+——————-+———–+———+———————-+——+——-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+——+——————-+———–+———+———————-+——+——-+<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t4&nbsp;|&nbsp;ALL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;NULL&nbsp;|&nbsp;1000&nbsp;|&nbsp;|<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t3&nbsp;|&nbsp;ref&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;idx_t3_id&nbsp;|&nbsp;4&nbsp;|&nbsp;dbatest.t4.accountid&nbsp;|&nbsp;1&nbsp;|&nbsp;|<br />　　+—-+————-+——-+——+——————-+———–+———+———————-+——+——-+<br />　　2&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)</td></tr></tbody></table><p>　　(5). ref_or_null</p><p>　　该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。</p><p>　　在下面的例子中，MySQL可以使用ref_or_null联接来处理ref_tables：</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">SELECT&nbsp;*&nbsp;FROM&nbsp;ref_table<br />WHERE&nbsp;key_column=expr&nbsp;OR&nbsp;key_column&nbsp;IS&nbsp;NULL;</td></tr></tbody></table><p>　　(6). index_merge</p><p>　　该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。</p><p>　　例如:</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t4&nbsp;where&nbsp;id=3952602&nbsp;or&nbsp;accountid=31754306&nbsp;;<br />　　+—-+————-+——-+————-+—————————-+—————————-+———+——+——+——————————————————+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+————-+—————————-+—————————-+———+——+——+——————————————————+<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t4&nbsp;|&nbsp;index_merge&nbsp;|&nbsp;idx_t4_id,idx_t4_accountid&nbsp;|&nbsp;idx_t4_id,idx_t4_accountid&nbsp;|&nbsp;4,4&nbsp;|&nbsp;NULL&nbsp;|&nbsp;2&nbsp;|&nbsp;Using&nbsp;union(idx_t4_id,idx_t4_accountid);&nbsp;Using&nbsp;where&nbsp;|<br />　　+—-+————-+——-+————-+—————————-+—————————-+———+——+——+——————————————————+<br />　　1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)</td></tr></tbody></table><p>　　(7). unique_subquery</p><p>　　该类型替换了下面形式的IN子查询的ref：</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">value&nbsp;IN&nbsp;(SELECT&nbsp;primary_key&nbsp;FROM&nbsp;single_table&nbsp;WHERE&nbsp;some_expr)</td></tr></tbody></table><p>　　unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。</p><p>　(8).index_subquery</p><p>　　该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">value&nbsp;IN&nbsp;(SELECT&nbsp;key_column&nbsp;FROM&nbsp;single_table&nbsp;WHERE&nbsp;some_expr)</td></tr></tbody></table><p>　　(9).range</p><p>　　只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。</p><p>　　当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range</p><table style="table-layout: fixed; border: 1px dotted rgb(204, 204, 204);" align="center" border="0" cellpadding="6" cellspacing="0" width="95%"><tbody><tr><td style="word-wrap: break-word;" bgcolor="#f3f3f3">mysql&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;t3&nbsp;where&nbsp;id=3952602&nbsp;or&nbsp;id=3952603&nbsp;;<br />　　+—-+————-+——-+——-+——————-+———–+———+——+——+————-+<br />　　|&nbsp;id&nbsp;|&nbsp;select_type&nbsp;|&nbsp;table&nbsp;|&nbsp;type&nbsp;|&nbsp;possible_keys&nbsp;|&nbsp;key&nbsp;|&nbsp;key_len&nbsp;|&nbsp;ref&nbsp;|&nbsp;rows&nbsp;|&nbsp;Extra&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———–+———+——+——+————-+<br />　　|&nbsp;1&nbsp;|&nbsp;SIMPLE&nbsp;|&nbsp;t3&nbsp;|&nbsp;range&nbsp;|&nbsp;PRIMARY,idx_t3_id&nbsp;|&nbsp;idx_t3_id&nbsp;|&nbsp;4&nbsp;|&nbsp;NULL&nbsp;|&nbsp;2&nbsp;|&nbsp;Using&nbsp;where&nbsp;|<br />　　+—-+————-+——-+——-+——————-+———–+———+——+——+————-+<br />　　1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.02&nbsp;sec)<br />　　(10).index</td></tr></tbody></table><p>　　该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。</p><p>　　当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。</p><p>　　(11). ALL</p><p>　　对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。</p><p>　　<strong>5.possible_keys</strong></p><p>　　possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。</p><p>　　如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p><p>　　<strong>6. key</strong></p><p>　　key列显示MySQL实际决定使用的键(索引)。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p><p>　<strong>　7.key_len</strong></p><p>　　key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。</p><p>　　使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>　<strong>　8. ref</strong></p><p>　　ref列显示使用哪个列或常数与key一起从表中选择行。</p><p>　　<strong>9. rows</strong></p><p>　　rows列显示MySQL认为它执行查询时必须检查的行数。</p><p>　　<strong>10. Extra</strong></p><p><strong>　　</strong>该列包含MySQL解决查询的详细信息,下面详细.</p><p>　　(1).Distinct</p><p>　　一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p><p>　　(2).Not exists</p><p>　　MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，</p><p>　　就不再搜索了</p><p>　　(3).Range checked for each</p><p>　　Record(index map:#)</p><p>　　没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一</p><p>　　(4).Using filesort</p><p>　　看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行</p><p>　　(5).Using index</p><p>　　列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候</p><p>　　(6).Using temporary</p><p>　　看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上</p><p>　　(7).Using where</p><p>　　使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题</p></div></div><ul id="flip2" class="flip"><li>Newer:<a href="http://sk2.com/post/223.html">表单过期的处理（提交出错后返回，保存原来数据)</a></li><li>Older:<a href="http://sk2.com/post/221.html">jQuery性能优化指南</a></li></ul></div>
<div id="footer"><div><a rel="nofollow" class="admin" href="http://sk2.com/login"><small>ADMIN</small></a><address>&copy; 2010 <a href='http://sk2.com/'>blog.sk80.com</a></address></div></div></div></div><script type="text/javascript" src="http://sk2.com/include/js/resize.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">try {var pageTracker = _gat._getTracker("UA-5695529-2");pageTracker._trackPageview();} catch(err) {}</script></body></html>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/3688801.js"></script>
<noscript><a href="http://www.51.la/?3688801" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/3688801.asp" style="border:none" /></a></noscript>