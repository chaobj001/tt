<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="generator" content="blog.sk80.com" /><meta name="keywords" content="mysql索引简单介绍:Mysql," /><meta name="description" content="mysql索引简单介绍,半小时精通正则表达式,MySQL索引分析和优化" /><meta name="author" content="4kychao" /><link rel="stylesheet" type="text/css" href="http://sk2.com/templates/default/style.css" /><title>mysql索引简单介绍</title></head><body><div id="wrapper"><div id="header"><div id="header-inner"><p class="sitename">blog.sk80.com</p><div class="description">等我有钱了, 咱买棒棒糖, 买2 根, 1 根 你看着我吃, 另1根 我吃给你看。</div><div class="menu"><ul><li class="current_page"><a rel="nofollow" href="/">日志</a></li><!--li><a href="#">About</a></li--></ul></div></div></div><div id="wrapper-inner"><p id="topic-path"><a href="/" rel="nofollow">Home</a>&gt;<a href="http://sk2.com/category/mysql/">Mysql</a>&gt;<strong class="current">mysql索引简单介绍</strong></p><ul id="flip1" class="flip"><li class="newer"><a title="半小时精通正则表达式" href="http://sk2.com/post/183.html" rel="nofollow">Newer</a></li><li class="older"><a title="MySQL索引分析和优化" href="http://sk2.com/post/181.html" rel="nofollow">Older</a></li></ul><div id="detail"><div class="post"><h1>mysql索引简单介绍</h1><ul class="info"><li class="date">2010年 04月 7日  17:56</li><li class="category"><a href="http://sk2.com/category/mysql/">Mysql</a></li></ul><div class="textbody">在数据库表中，使用索引可以大大提高查询速度。不过索引只是提高效率的一个因素。如果你的MySQL有大数据的表，就需要花时间研究建立最优秀的索引或优化查询语句。<a name="entrymore"></a><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<strong>一、索引分单列索引和组合索引</strong><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;单列索引：即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。<br />&nbsp;&nbsp;&nbsp;&nbsp;组合索引：即一个索包含多个列。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<strong>二、介绍一下索引的类型</strong><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">1.普通索引。</span><br />&nbsp;&nbsp;&nbsp;&nbsp;这是最基本的索引，它没有任何限制。它有以下几种创建方式：<br />&nbsp;&nbsp;&nbsp;&nbsp;（1）创建索引：CREATE INDEX indexName ON tableName(tableColumns(length));如果是CHAR,VARCHAR类型，length可以小于字段实际长度;如果是 BLOB 和 TEXT 类型，必须指定length，下同。<br />&nbsp;&nbsp;&nbsp;&nbsp;（2）修改表结构：ALTER tableName ADD INDEX [indexName] ON (tableColumns(length))<br />&nbsp;&nbsp;&nbsp;&nbsp;（3）创建表的时候直接指定：CREATE TABLE tableName ( [...], INDEX [indexName] (tableColumns(length)) ;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">2.唯一索引。</span><br />&nbsp;&nbsp;&nbsp;&nbsp;它与前面的"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：<br />&nbsp;&nbsp;&nbsp;&nbsp;（1）创建索引：CREATE UNIQUE INDEX indexName ON tableName(tableColumns(length))<br />&nbsp;&nbsp;&nbsp;&nbsp;（2）修改表结构：ALTER tableName ADD UNIQUE [indexName] ON (tableColumns(length))<br />&nbsp;&nbsp;&nbsp;&nbsp;（3）创建表的时候直接指定：CREATE TABLE tableName ( [...], UNIQUE [indexName] (tableColumns(length));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">3.主键索引</span><br />&nbsp;&nbsp;&nbsp;&nbsp;它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：CREATE TABLE testIndex(i_testID INT NOT NULL AUTO_INCREMENT,vc_Name VARCHAR(16) NOT NULL,PRIMARY KEY(i_testID)); 当然也可以用ALTER命令。<br />记住：一个表只能有一个主键。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">4.全文索引</span><br />&nbsp;&nbsp;&nbsp;&nbsp;MySQL从3.23.23版开始支持全文索引和全文检索。这里不作讨论，删除索引的语法：DROP INDEX index_name ON tableName<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;<strong>三、单列索引和组合索引</strong><br /><br /><p>&nbsp;&nbsp;&nbsp;&nbsp;为了形象地对比两者，再建一个表：</p><p><div class="code"><pre class="sql" style="font-family:Andale Mono,Lucida Console,Monaco,fixed,monospace;"><span style="color: #993333; font-weight: bold;">CREATE</span> <span style="color: #993333; font-weight: bold;">TABLE</span> myIndex <span style="color: #66cc66;">&#40;</span> i_testID INT <span style="color: #993333; font-weight: bold;">NOT</span> <span style="color: #993333; font-weight: bold;">NULL</span> <span style="color: #993333; font-weight: bold;">AUTO_INCREMENT</span><span style="color: #66cc66;">,</span> vc_Name VARCHAR<span style="color: #66cc66;">&#40;</span><span style="color: #cc66cc;">50</span><span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">NOT</span> <span style="color: #993333; font-weight: bold;">NULL</span><span style="color: #66cc66;">,</span> vc_City VARCHAR<span style="color: #66cc66;">&#40;</span><span style="color: #cc66cc;">50</span><span style="color: #66cc66;">&#41;</span> <span style="color: #993333; font-weight: bold;">NOT</span> <span style="color: #993333; font-weight: bold;">NULL</span><span style="color: #66cc66;">,</span> i_Age INT <span style="color: #993333; font-weight: bold;">NOT</span> <span style="color: #993333; font-weight: bold;">NULL</span><span style="color: #66cc66;">,</span> i_SchoolID INT <span style="color: #993333; font-weight: bold;">NOT</span> <span style="color: #993333; font-weight: bold;">NULL</span><span style="color: #66cc66;">,</span> <span style="color: #993333; font-weight: bold;">PRIMARY</span> <span style="color: #993333; font-weight: bold;">KEY</span> <span style="color: #66cc66;">&#40;</span>i_testID<span style="color: #66cc66;">&#41;</span> <span style="color: #66cc66;">&#41;</span>;</pre></div></p><p>&nbsp;&nbsp;&nbsp; 在这10000条记录里面7上8下地分布了5条vc_Name="erquan"的记录，只不过city,age,school的组合各不相同。来看这条 T-SQL： SELECT i_testID FROM myIndex WHERE vc_Name=@#erquan@# AND vc_City=@#郑州@# AND i_Age=25;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;首先考虑建单列索引：<br />&nbsp;&nbsp;&nbsp;&nbsp;在vc_Name列上建立了索引。执行T-SQL时，MYSQL很快将目标锁定在了vc_Name=erquan的5条记录上，取出来放到一中间结果集。在这个结果集里，先排除掉vc_City不等于"郑州"的记录，再排除i_Age不等于25的记录，最后筛选出唯一的符合条件的记录。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;虽然在vc_Name上建立了索引，查询时MYSQL不用扫描整张表，效率有所提高，但离我们的要求还有一定的距离。同样的，在vc_City和i_Age分别建立的单列索引的效率相似。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将vc_Name,vc_City,i_Age建到一个索引里：<br />&nbsp;&nbsp;&nbsp;&nbsp;ALTER TABLE myIndex ADD INDEX name_city_age (vc_Name(10),vc_City,i_Age);--注意了，建表时，vc_Name长度为50，这里为什么用10呢？因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;执行T-SQL时，MySQL无须扫描任何记录就到找到唯一的记录！！<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;肯定有人要问了，如果分别在vc_Name,vc_City,i_Age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率一样吧？嘿嘿，大不一样，远远低于我们的组合索引~~虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;建立这样的组合索引，其实是相当于分别建立了 vc_Name,vc_City,i_Age<br />vc_Name,vc_City<br />vc_Name<br />&nbsp;&nbsp;&nbsp;&nbsp;这样的三个组合索引！为什么没有vc_City,i_Age等这样的组合索引呢？这是因为mysql组合索引"<span style="color:#ff0000;">最左前缀</span>"的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个T-SQL会用到： SELECT * FROM myIndex WHREE vc_Name="erquan" AND vc_City="郑州"<br />SELECT * FROM myIndex WHREE vc_Name="erquan"<br />&nbsp;&nbsp;&nbsp;&nbsp;而下面几个则不会用到： SELECT * FROM myIndex WHREE i_Age=20 AND vc_City="郑州"<br />SELECT * FROM myIndex WHREE vc_City="郑州"<br /><br /> <strong> 四、使用索引</strong><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;到此你应该会建立、使用索引了吧？但什么情况下需要建立索引呢？一般来说，<span style="color:#ff0000;">在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为 MySQL只对 &lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE(后面有说明)才会使用索引。</span><br />SELECT t.vc_Name FROM testIndex t LEFT JOIN myIndex m ON t.vc_Name=m.vc_Name WHERE m.i_Age=20 AND m.vc_City=@#郑州@# 时，有对myIndex表的vc_City和i_Age建立索引的需要，由于testIndex表的vc_Name开出现在了JOIN子句中，也有对它建立索引的必要。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;刚才提到了，只有某些时候的LIKE才需建立索引？是的。因为在以通配符 % 和 _ 开头作查询时，MySQL不会使用索引，如<br /><br /><br />SELECT * FROM myIndex WHERE vc_Name like@#erquan%@#<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;会使用索引，而<br /><br />SELECT * FROM myIndex WHEREt vc_Name like@#%erquan@#<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;就不会使用索引了。<br /><br /><strong>&nbsp;&nbsp;&nbsp;&nbsp;五、索引的不足之处</strong><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;上面说了那么多索引的好话，它真的有像传说中那么优秀么？当然会有缺点了。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;1.虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;2.建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。<br /></p></div></div><ul id="flip2" class="flip"><li>Newer:<a href="http://sk2.com/post/183.html">半小时精通正则表达式</a></li><li>Older:<a href="http://sk2.com/post/181.html">MySQL索引分析和优化</a></li></ul></div>
<div id="footer"><div><a rel="nofollow" class="admin" href="http://sk2.com/login"><small>ADMIN</small></a><address>&copy; 2010 <a href='http://sk2.com/'>blog.sk80.com</a></address></div></div></div></div><script type="text/javascript" src="http://sk2.com/include/js/resize.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">try {var pageTracker = _gat._getTracker("UA-5695529-2");pageTracker._trackPageview();} catch(err) {}</script></body></html>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/3688801.js"></script>
<noscript><a href="http://www.51.la/?3688801" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/3688801.asp" style="border:none" /></a></noscript>