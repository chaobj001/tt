<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="generator" content="blog.sk80.com" /><meta name="keywords" content="Memcache 协议（中英对照）:技术相关,memcache " /><meta name="description" content="Memcache 协议（中英对照）,PHP缓存技术：memcache函数详解之一,DNS-劫持配置" /><meta name="author" content="4kychao" /><link rel="stylesheet" type="text/css" href="http://sk2.com/templates/default/style.css" /><title>Memcache 协议（中英对照）</title></head><body><div id="wrapper"><div id="header"><div id="header-inner"><p class="sitename">blog.sk80.com</p><div class="description">等我有钱了, 咱买棒棒糖, 买2 根, 1 根 你看着我吃, 另1根 我吃给你看。</div><div class="menu"><ul><li class="current_page"><a rel="nofollow" href="/">日志</a></li><!--li><a href="#">About</a></li--></ul></div></div></div><div id="wrapper-inner"><p id="topic-path"><a href="/" rel="nofollow">Home</a>&gt;<a href="http://sk2.com/category/technical/">技术相关</a>&gt;<strong class="current">Memcache 协议（中英对照）</strong></p><ul id="flip1" class="flip"><li class="newer"><a title="PHP缓存技术：memcache函数详解之一" href="http://sk2.com/post/212.html" rel="nofollow">Newer</a></li><li class="older"><a title="DNS-劫持配置" href="http://sk2.com/post/210.html" rel="nofollow">Older</a></li></ul><div id="detail"><div class="post"><h1>Memcache 协议（中英对照）</h1><ul class="info"><li class="date">2010年 04月10日  18:11</li><li class="category"><a href="http://sk2.com/category/technical/">技术相关</a></li></ul><div class="textbody"><p>在memcache协议中发送的数据分两种：文本行 和 自由数据。 文本行被用于来自客户端的命令和服务器的回应。自由数据用于客户端从服务器端存取数据时。存储在memcached中的数据通过键值来标识。键值是一个文本字符串，对于需要存取这项数据的客户端而言，它必须是唯一的。</p><p></p><table border="0" cellpadding="4" cellspacing="1" width="100%"><tbody><tr><td style="color: rgb(51, 102, 0);" width="50%"><h5>协议</h5></td><td style="color: rgb(51, 102, 0);" width="50%"><h5>Protocol</h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">memcached 的客户端使用TCP链接 与 服务器通讯。（UDP接口也同样有效，参考后文的 “UDP协议” ）一个运行中的memcached服务器监视一些（可设置）端口。客户端连接这些端口，发送命令到服务器，读取回应，最后关闭连接。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Clients of memcached communicate with server through TCP connections. (A UDP interface is also available; details are below under “UDP protocol.”) A given running memcached server listens on some (configurable) port; clients connect to that port, send commands to the server, read responses, and eventually close the connection.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">结束会话不需要发送任何命令。当不再需memcached服务时，要客户端可以在任何时候关闭连接。需要注意的是，鼓励客户端缓存这些连接，而不是每次需要存取数据时都重新打开连接。这是因为memcached 被特意设计成及时开启很多连接也能够高效的工作（数百个，上千个如果需要的话）。缓存这些连接，可以消除建立连接所带来的开销（/*/相对而言，在服务器端建立一个新连接的准备工作所带来的开销，可以忽略不计。）。</td><td style="font-size: 13px; line-height: 20px;" valign="top">There is no need to send any command to end the session. A client may just close the connection at any moment it no longer needs it. Note, however, that clients are encouraged to cache their connections rather than reopen them every time they need to store or retrieve data. This is because memcached is especially designed to work very efficiently with a very large number (many hundreds, more than a thousand if necessary) of open connections. Caching connections will eliminate the overhead associated with establishing a TCP connection (the overhead of preparing for a new connection on the server side is insignificant compared to this).</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">在memcache协议中发送的数据分两种：文本行 和 自由数据。 文本行被用于来自客户端的命令和服务器的回应。自由数据用于客户端从服务器端存取数据时。同样服务器会以字节流的方式传回自由数据。/*/服务器不用关心自由数据的字节顺序。自由数据的特征没有任何限制；但是通过前文提到的文本行，这项数据的接受者（服务器或客户端），便能够精确地获知所发送的数据库的长度。</td><td style="font-size: 13px; line-height: 20px;" valign="top">There are two kinds of data sent in the memcache protocol: text lines<br />and unstructured data. Text lines are used for commands from clients<br />and responses from servers. Unstructured data is sent when a client<br />wants to store or retrieve data. The server will transmit back<br />unstructured data in exactly the same way it received it, as a byte<br />stream. The server doesn’t care about byte order issues in<br />unstructured data and isn’t aware of them. There are no limitations on<br />characters that may appear in unstructured data; however, the reader<br />of such data (either a client or a server) will always know, from a<br />preceding text line, the exact length of the data block being<br />transmitted.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">文本行固定以“\r\n”(回车符紧跟一个换行符)结束。 自由数据也是同样会以“\r\n”结束，但是 \r(回车符)、\n(换行符)，以及任何其他8位字符，均可出现在数据中。因此，当客户端从服务器取回数据时，必须使用数据区块的长度来确定数据区块的结束位置，而不要依据数据区块末尾的“\r\n”，即使它们固定存在于此。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Text lines are always terminated by \r\n. Unstructured data is _also_<br />terminated by \r\n, even though \r, \n or any other 8-bit characters<br />may also appear inside the data. Therefore, when a client retrieves<br />data from a server, it must use the length of the data block (which it<br />will be provided with) to determine where the data block ends, and not<br />the fact that \r\n follows the end of the data block, even though it<br />does.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5>键值</h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5>Keys</h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">存储在memcached中的数据通过键值来标识。键值是一个文本字符串，对于需要存取这项数据的客户端而言，它必须是唯一的。键值当前的长度限制设定为250字符（当然，客户端通常不会用到这么长的键）；键值中不能使用制表符和其他空白字符（例如空格，换行等）。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Data stored by memcached is identified with the help of a key. A key<br />is a text string which should uniquely identify the data for clients<br />that are interested in storing and retrieving it. Currently the<br />length limit of a key is set at 250 characters (of course, normally<br />clients wouldn’t need to use such long keys); the key must not include<br />control characters or whitespace.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5>命令</h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5>Commands</h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">所有命令分为3种类型</td><td style="font-size: 13px; line-height: 20px;" valign="top">There are three types of commands.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">存储命令（有3项：’set’、’add’、’repalce’）指示服务器储存一些由键值标识的数据。客户端发送一行命令，后面跟着数据区块；然后，客户端等待接收服务器回传的命令行，指示成功与否。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Storage commands (there are three: “set”, “add” and “replace”) ask the<br />server to store some data identified by a key. The client sends a<br />command line, and then a data block; after that the client expects one<br />line of response, which will indicate success or faulure.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">取回命令（只有一项：’get’）指示服务器返回与所给键值相符合的数据（一个请求中右一个或多个键值）。客户端发送一行命令，包括所有请求的键值；服务器每找到一项内容，都会发送回客户端一行关于这项内容的信息，紧跟着是对应的数据区块；直到服务器以一行“END”回应命令结束。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Retrieval commands (there is only one: “get”) ask the server to<br />retrieve data corresponding to a set of keys (one or more keys in one<br />request). The client sends a command line, which includes all the<br />requested keys; after that for each item the server finds it sends to<br />the client one response line with information about the item, and one<br />data block with the item’s data; this continues until the server<br />finished with the “END” response line.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">/*?*/其他的命令都不能携带自由数据。在这些命令中，客户端发送一行命令，然后等待（由命令所决定）一行回应，或最终以一行“END”结束的多行命令。</td><td style="font-size: 13px; line-height: 20px;" valign="top">All other commands don’t involve unstructured data. In all of them,<br />the client sends one command line, and expects (depending on the<br />command) either one line of response, or several lines of response<br />ending with “END” on the last line.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">一行命令固定以命令名称开始，接着是以空格隔开的参数（如果有参数的话）。命令名称大小写敏感，并且必须小写。</td><td style="font-size: 13px; line-height: 20px;" valign="top">A command line always starts with the name of the command, followed by<br />parameters (if any) delimited by whitespace. Command names are<br />lower-case and are case-sensitive.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">一些客户端发送给服务器的命令会包含一些时限（针对内容或客户端请求的操作）。这时，时限的具体内容既可以是Unix时间戳（从1970年1月1日开始的秒钟数），或当前时间开始的秒钟数。对后者而言，不能超过 60*60*24*30（30天）；如果超出，服务器将会理解为Unix时间戳，而不是从当前时间起的秒偏移。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Some commands involve a client sending some kind of expiration time<br />(relative to an item or to an operation requested by the client) to<br />the server. In all such cases, the actual value sent may either be<br />Unix time (number of seconds since January 1, 1970, as a 32-bit<br />value), or a number of seconds starting from current time. In the<br />latter case, this number of seconds may not exceed 60*60*24*30 (number<br />of seconds in 30 days); if the number sent by a client is larger than<br />that, the server will consider it to be real Unix time value rather<br />than an offset from current time.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5>错误字串</h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5>Error strings</h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">每一个由客户端发送的命令，都可能收到来自服务器的错误字串回复。这些错误字串会以三种形式出现：</td><td style="font-size: 13px; line-height: 20px;" valign="top">Each command sent by a client may be answered with an error string<br />from the server. These error strings come in three types:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “ERROR\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">意味着客户端发送了不存在的命令名称。</td><td style="font-size: 13px; line-height: 20px;" valign="top">means the client sent a nonexistent command name.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “CLIENT_ERROR &lt;error&gt;\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">意味着输入的命令行里存在一些客户端错误，例如输入未遵循协议。&lt;error&gt;部分是人类易于理解的错误解说……</td><td style="font-size: 13px; line-height: 20px;" valign="top">means some sort of client error in the input line, i.e. the input<br />doesn’t conform to the protocol in some way. &lt;error&gt; is a<br />human-readable error string.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “SERVER_ERROR &lt;error&gt;\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">意味着一些服务器错误，导致命令无法执行。&lt;error&gt;部分是人类易于理解的错误解说。在一些严重的情形下（通常应该不会遇到），服务器将在发送这行错误后关闭连接。这是服务器主动关闭连接的唯一情况。</td><td style="font-size: 13px; line-height: 20px;" valign="top">means some sort of server error prevents the server from carrying<br />out the command. &lt;error&gt; is a human-readable error string. In cases<br />of severe server errors, which make it impossible to continue<br />serving the client (this shouldn’t normally happen), the server will<br />close the connection after sending the error line. This is the only<br />case in which the server closes a connection to a client.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">在后面每项命令的描述中，这些错误行不会再特别提到，但是客户端必须考虑到这些它们存在的可能性。</td><td style="font-size: 13px; line-height: 20px;" valign="top">In the descriptions of individual commands below, these error lines<br />are not again specifically mentioned, but clients must allow for their<br />possibility.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">存储命令</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">Storage commands</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">首先，客户端会发送一行像这样的命令：</td><td style="font-size: 13px; line-height: 20px;" valign="top">First, the client sends a command line which looks like this:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">&lt;command name&gt; &lt;key&gt; &lt;flags&gt; &lt;exptime&gt; &lt;bytes&gt;\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;command name&gt; 是 set, add, 或者 repalce</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;command name&gt; is “set”, “add” or “replace”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top"><ul><li>set 意思是 “储存此数据”</li><li>add 意思是 “储存此数据，只在服务器*未*保留此键值的数据时”</li><li>replace意思是 “储存此数据，只在服务器*曾*保留此键值的数据时”</li></ul></td><td style="font-size: 13px; line-height: 20px;" valign="top"><ul><li>“set” means “store this data”.</li><li>“add” means “store this data, but only if the server *doesn’t* already<br />hold data for this key”.</li><li>“replace” means “store this data, but only if the server *does*<br />already hold data for this key”.</li></ul></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; 是接下来的客户端所要求储存的数据的键值</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; is the key under which the client asks to store the data</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;flags&gt; 是在取回内容时，与数据和发送块一同保存服务器上的任意16位无符号整形（用十进制来书写）。客户端可以用它作为“位域”来存储一些特定的信息；它对服务器是不透明的。</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;flags&gt; is an arbitrary 16-bit unsigned integer (written out in<br />decimal) that the server stores along with the data and sends back<br />when the item is retrieved. Clients may use this as a bit field to<br />store data-specific information; this field is opaque to the server.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;exptime&gt; 是终止时间。如果为0，该项永不过期(虽然它可能被删除，以便为其他缓存项目腾出位置)。如果非0（Unix时间戳或当前时刻的秒偏移），到达终止时间后，客户端无法再获得这项内容。</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;exptime&gt; is expiration time. If it’s 0, the item never expires<br />(although it may be deleted from the cache to make place for other<br />items). If it’s non-zero (either Unix time or offset in seconds from<br />current time), it is guaranteed that clients will not be able to<br />retrieve this item after the expiration time arrives (measured by<br />server time).</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;bytes&gt; 是随后的数据区块的字节长度，不包括用于分野的“\r\n”。它可以是0（这时后面跟随一个空的数据区块）。</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;bytes&gt; is the number of bytes in the data block to follow, *not*<br />including the delimiting \r\n. &lt;bytes&gt; may be zero (in which case<br />it’s followed by an empty data block).</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">在这一行以后，客户端发送数据区块。</td><td style="font-size: 13px; line-height: 20px;" valign="top">After this line, the client sends the data block:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">&lt;data block&gt;\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;data block&gt; 是大段的8位数据，其长度由前面的命令行中的&lt;bytes&gt;指定。</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;data block&gt; is a chunk of arbitrary 8-bit data of length &lt;bytes&gt;<br />from the previous line.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">发送命令行和数据区块以后，客户端等待回复，可能的回复如下：</td><td style="font-size: 13px; line-height: 20px;" valign="top">After sending the command line and the data blockm the client awaits<br />the reply, which may be:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “STORED\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">表明成功.</td><td style="font-size: 13px; line-height: 20px;" valign="top">to indicate success.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “NOT_STORED\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">表明数据没有被存储，但不是因为发生错误。这通常意味着add 或 replace命令的条件不成立，或者，项目已经位列删除队列（参考后文的“delete”命令）。</td><td style="font-size: 13px; line-height: 20px;" valign="top">to indicate the data was not stored, but not<br />because of an error. This normally means that either that the<br />condition for an “add” or a “replace” command wasn’t met, or that the<br />item is in a delete queue (see the “delete” command below).</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">取回命令</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">Retrieval command</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">一行取回命令如下：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The retrieval command looks like this:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">get &lt;key&gt;*\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt;* 表示一个或多个键值，由空格隔开的字串</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt;* means one or more key strings separated by whitespace.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">这行命令以后，客户端的等待0个或多个项目，每项都会收到一行文本，然后跟着数据区块。所有项目传送完毕后，服务器发送以下字串：</td><td style="font-size: 13px; line-height: 20px;" valign="top">After this command, the client expects zero or more items, each of<br />which is received as a text line followed by a data block. After all<br />the items have been transmitted, the server sends the string</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">“END\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">来指示回应完毕。</td><td style="font-size: 13px; line-height: 20px;" valign="top">to indicate the end of response.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">服务器用以下形式发送每项内容：</td><td style="font-size: 13px; line-height: 20px;" valign="top">Each item sent by the server looks like this:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">VALUE &lt;key&gt; &lt;flags&gt; &lt;bytes&gt;\r\n<br />&lt;data block&gt;\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; 是所发送的键名</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; is the key for the item being sent</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;flags&gt; 是存储命令所设置的记号</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;flags&gt; is the flags value set by the storage command</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;bytes&gt; 是随后数据块的长度，*不包括* 它的界定符“\r\n”</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;bytes&gt; is the length of the data block to follow, *not* including<br />its delimiting \r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;data block&gt; 是发送的数据</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;data block&gt; is the data for this item.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">如果在取回请求中发送了一些键名，而服务器没有送回项目列表，这意味着服务器没这些键名（可能因为它们从未被存储，或者为给其他内容腾出空间而被删除，或者到期，或者被已客户端删除）。</td><td style="font-size: 13px; line-height: 20px;" valign="top">If some of the keys appearing in a retrieval request are not sent back<br />by the server in the item list this means that the server does not<br />hold items with such keys (because they were never stored, or stored<br />but deleted to make space for more items, or expired, or explicitly<br />deleted by a client).</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">删除</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">Deletion</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">命令“delete”允许从外部删除内容：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The command “delete” allows for explicit deletion of items:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">delete &lt;key&gt; &lt;time&gt;\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; 是客户端希望服务器删除的内容的键名</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; is the key of the item the client wishes the server to delete</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;time&gt; 是一个单位为秒的时间（或代表直到某一刻的Unix时间），在该时间内服务器会拒绝对于此键名的“add”和“replace”命令。此时内容被放入delete队列，无法再通过“get”得到该内容，也无法是用“add”和“replace”命令（但是“set”命令可用）。直到指定时间，这些内容被最终从服务器的内存中彻底清除。</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;time&gt; is the amount of time in seconds (or Unix time until which)<br />the client wishes the server to refuse “add” and “replace” commands<br />with this key. For this amount of item, the item is put into a<br />delete queue, which means that it won’t possible to retrieve it by<br />the “get” command, but “add” and “replace” command with this key<br />will also fail (the “set” command will succeed, however). After the<br />time passes, the item is finally deleted from server memory.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&lt;time&gt;参数 是可选的，缺省为0（表示内容会立刻清除，并且随后的存储命令均可用）。</td><td style="font-size: 13px; line-height: 20px;" valign="top">The parameter &lt;time&gt; is optional, and, if absent, defaults to 0<br />(which means that the item will be deleted immediately and further<br />storage commands with this key will succeed).</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">此命令有一行回应：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The response line to this command can be one of:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “DELETED\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">表示执行成功</td><td style="font-size: 13px; line-height: 20px;" valign="top">to indicate success</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “NOT_FOUND\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">表示没有找到这项内容</td><td style="font-size: 13px; line-height: 20px;" valign="top">to indicate that the item with this key was not found.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">参考随后的“flush_all”命令使所有内容无效</td><td style="font-size: 13px; line-height: 20px;" valign="top">See the “flush_all” command below for immediate invalidation<br />of all existing items.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">增加/减少</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">Increment/Decrement</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">命令 “incr” 和 “decr”被用来修改数据，当一些内容需要 替换、增加 或减少时。这些数据必须是十进制的32位无符号整新。如果不是，则当作0来处理。修改的内容必须存在，当使用“incr”/“decr”命令修改不存在的内容时，不会被当作0处理，而是操作失败。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Commands “incr” and “decr” are used to change data for some item<br />in-place, incrementing or decrementing it. The data for the item is<br />treated as decimal representation of a 32-bit unsigned integer. If the<br />current data value does not conform to such a representation, the<br />commands behave as if the value were 0. Also, the item must already<br />exist for incr/decr to work; these commands won’t pretend that a<br />non-existent key exists with value 0; instead, they will fail.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">客户端发送命令行：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The client sends the command line:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">incr &lt;key&gt; &lt;value&gt;\r\n<br />或<br />decr &lt;key&gt; &lt;value&gt;\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; 是客户端希望修改的内容的建名</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;key&gt; is the key of the item the client wishes to change</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;value&gt; 是客户端要增加/减少的总数。</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;value&gt; is the amount by which the client wants to increase/decrease<br />the item. It is a decimal representation of a 32-bit unsigned integer.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">回复为以下集中情形：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The response will be one of:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">- “NOT_FOUND\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">指示该项内容的值，不存在。</td><td style="font-size: 13px; line-height: 20px;" valign="top">to indicate the item with this value was not found</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;value&gt;\r\n ，&lt;value&gt;是 增加/减少 。</td><td style="font-size: 13px; line-height: 20px;" valign="top">- &lt;value&gt;\r\n , where &lt;value&gt; is the new value of the item’s data,<br />after the increment/decrement operation was carried out.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">注意”decr”命令发生下溢：如果客户端尝试减少的结果小于0时，结果会是0。”incr” 命令不会发生溢出。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Note that underflow in the “decr” command is caught: if a client tries<br />to decrease the value below 0, the new value will be 0. Overflow in<br />the “incr” command is not checked.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">……<p></p></td><td style="font-size: 13px; line-height: 20px;" valign="top">Note also that decrementing a number such that it loses length isn’t<br />guaranteed to decrement its returned length. The number MAY be<br />space-padded at the end, but this is purely an implementation<br />optimization, so you also shouldn’t rely on that.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">状态</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">Statistics</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">命令”stats” 被用于查询服务器的运行状态和其他内部数据。有两种格式。不带参数的：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The command “stats” is used to query the server about statistics it<br />maintains and other internal data. It has two forms. Without<br />arguments:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top"><span style="color: rgb(204, 204, 204);">&nbsp;</span>stats\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">这会在随后输出各项状态、设定值和文档。另一种格式带有一些参数：</td><td style="font-size: 13px; line-height: 20px;" valign="top">it causes the server to output general-purpose statistics and<br />settings, documented below. In the other form it has some arguments:<p></p></td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">stats &lt;args&gt;\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">通过&lt;args&gt;，服务器传回各种内部数据。因为随时可能发生变动，本文不提供参数的种类及其传回数据。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Depending on &lt;args&gt;, various internal data is sent by the server. The<br />kinds of arguments and the data sent are not documented in this vesion<br />of the protocol, and are subject to change for the convenience of<br />memcache developers.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">各种状态</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">General-purpose statistics</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">受到无参数的”stats”命令后，服务器发送多行内容，如下：</td><td style="font-size: 13px; line-height: 20px;" valign="top">Upon receiving the “stats” command without arguments, the server sents<br />a number of lines which look like this:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">STAT &lt;name&gt; &lt;value&gt;\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">服务器用以下一行来终止这个清单：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The server terminates this list with the line</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">END\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">在每行状态中，&lt;name&gt; 是状态的名字，&lt;value&gt; 使状态的数据。 以下清单，是所有的状态名称，数据类型，和数据代表的含义。</td><td style="font-size: 13px; line-height: 20px;" valign="top">In each line of statistics, &lt;name&gt; is the name of this statistic, and<br />&lt;value&gt; is the data. The following is the list of all names sent in<br />response to the “stats” command, together with the type of the value<br />sent for this name, and the meaning of the value.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">在“类型”一列中，”32u”表示32位无符号整型，”64u”表示64位无符号整型，”32u:32u”表示用冒号隔开的两个32位无符号整型。</td><td style="font-size: 13px; line-height: 20px;" valign="top">In the type column below, “32u” means a 32-bit unsigned integer, “64u”<br />means a 64-bit unsigner integer. ‘32u:32u’ means two 32-but unsigned<br />integers separated by a colon.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" valign="top"><table bgcolor="#003366" border="0" cellpadding="0" cellspacing="0" width="94%"><tbody><tr><td><table style="font-size: 13px; line-height: 20px;" border="0" cellpadding="2" cellspacing="1" width="100%"><tbody><tr><td style="color: rgb(51, 102, 0);" align="center" bgcolor="#cc9933" valign="top" width="100"><strong><span style="font-size: 13px; line-height: 20px;">名称/Name</span></strong></td><td style="color: rgb(51, 102, 0);" align="center" bgcolor="#cc9933" valign="top" width="80"><strong><span style="font-size: 13px; line-height: 20px;">类型/Type</span></strong></td><td style="color: rgb(51, 102, 0);" colspan="2" align="center" bgcolor="#cc9933" valign="top"><strong><span style="font-size: 13px; line-height: 20px;">含义/</span>Meaning</strong></td></tr><tr><td bgcolor="#ffe3aa" valign="top">pid</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器进程ID</td><td bgcolor="#ffe3aa" valign="top">Process id of this server process</td></tr><tr><td bgcolor="#ffe3aa" valign="top">uptime</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器运行时间，单位秒</td><td bgcolor="#ffe3aa" valign="top">Number of seconds this server has been running</td></tr><tr><td bgcolor="#ffe3aa" valign="top">time</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器当前的UNIX时间</td><td bgcolor="#ffe3aa" valign="top">current UNIX time according to the server</td></tr><tr><td bgcolor="#ffe3aa" valign="top">version</td><td bgcolor="#ffe3aa" valign="top">string</td><td bgcolor="#ffe3aa" valign="top">服务器的版本号</td><td bgcolor="#ffe3aa" valign="top">Version string of this server</td></tr><tr><td bgcolor="#ffe3aa" valign="top">rusage_user</td><td bgcolor="#ffe3aa" valign="top">32u:32u</td><td bgcolor="#ffe3aa" valign="top">该进程累计的用户时间<br />(秒:微妙)</td><td bgcolor="#ffe3aa" valign="top">Accumulated user time for this process<br />(seconds:microseconds)</td></tr><tr><td bgcolor="#ffe3aa" valign="top">rusage_system</td><td bgcolor="#ffe3aa" valign="top">32u:32u</td><td bgcolor="#ffe3aa" valign="top">该进程累计的系统时间<br />(秒:微妙)</td><td bgcolor="#ffe3aa" valign="top">Accumulated system time for this process<br />(seconds:microseconds)</td></tr><tr><td bgcolor="#ffe3aa" valign="top">curr_items</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器当前存储的内容数量</td><td bgcolor="#ffe3aa" valign="top">Current number of items stored by the server</td></tr><tr><td bgcolor="#ffe3aa" valign="top">total_items</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器启动以来存储过的内容总数</td><td bgcolor="#ffe3aa" valign="top">Total number of items stored by this server<br />ever since it started</td></tr><tr><td bgcolor="#ffe3aa" valign="top">bytes</td><td bgcolor="#ffe3aa" valign="top">64u</td><td bgcolor="#ffe3aa" valign="top">服务器当前存储内容所占用的字节数</td><td bgcolor="#ffe3aa" valign="top">Current number of bytes used by this server<br />to store items</td></tr><tr><td bgcolor="#ffe3aa" valign="top">curr_connections</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">连接数量</td><td bgcolor="#ffe3aa" valign="top">Number of open connections</td></tr><tr><td bgcolor="#ffe3aa" valign="top">total_connections</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器运行以来接受的连接总数</td><td bgcolor="#ffe3aa" valign="top">Total number of connections opened since<br />the server started running</td></tr><tr><td bgcolor="#ffe3aa" valign="top">connection_structures</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器分配的连接结构的数量</td><td bgcolor="#ffe3aa" valign="top">Number of connection structures allocated<br />by the server</td></tr><tr><td bgcolor="#ffe3aa" valign="top">cmd_get</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">取回请求总数</td><td bgcolor="#ffe3aa" valign="top">Cumulative number of retrieval requests</td></tr><tr><td bgcolor="#ffe3aa" valign="top">cmd_set</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">存储请求总数</td><td bgcolor="#ffe3aa" valign="top">Cumulative number of storage requests</td></tr><tr><td bgcolor="#ffe3aa" valign="top">get_hits</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">请求成功的总次数</td><td bgcolor="#ffe3aa" valign="top">Number of keys that have been requested and<br />found present</td></tr><tr><td bgcolor="#ffe3aa" valign="top">get_misses</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">请求失败的总次数</td><td bgcolor="#ffe3aa" valign="top">Number of items that have been requested<br />and not found</td></tr><tr><td bgcolor="#ffe3aa" valign="top">bytes_read</td><td bgcolor="#ffe3aa" valign="top">64u</td><td bgcolor="#ffe3aa" valign="top">服务器从网络读取到的总字节数</td><td bgcolor="#ffe3aa" valign="top">Total number of bytes read by this server<br />from network</td></tr><tr><td bgcolor="#ffe3aa" valign="top">bytes_written</td><td bgcolor="#ffe3aa" valign="top">64u</td><td bgcolor="#ffe3aa" valign="top">服务器向网络发送的总字节数</td><td bgcolor="#ffe3aa" valign="top">Total number of bytes sent by this server to<br />network</td></tr><tr><td bgcolor="#ffe3aa" valign="top">limit_maxbytes</td><td bgcolor="#ffe3aa" valign="top">32u</td><td bgcolor="#ffe3aa" valign="top">服务器在存储时被允许使用的字节总数</td><td bgcolor="#ffe3aa" valign="top">Number of bytes this server is allowed to<br />use for storage.</td></tr></tbody></table></td></tr></tbody></table></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">其它命令</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">Other commands</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">“flush_all”命令有一个可选的数字参数。它总是执行成功，服务器会发送“OK\r\n”回应。它的效果是使已经存在的项目立即失效（缺省），或在指定的时间后。此后执行取回命令，将不会有任何内容返回（除非重新存储同样的键名）。flush_all 实际上没有立即释放项目所占用的内存，而是在随后陆续有新的项目被储存时执行。flush_all 效果具体如下：它导致所有更新时间早于flush_all所设定时间的项目，在被执行取回命令时命令被忽略。</td><td style="font-size: 13px; line-height: 20px;" valign="top">“flush_all” is a command with an optional numeric argument. It always succeeds, and the server sends “OK\r\n” in response. Its effect is to invalidate all existing items immediately (by default) or after the expiration specified. After invalidation none of the items will be returned in response to a retrieval command (unless it’s stored again under the same key *after* flush_all has invalidated the items). flush_all doesn’t actually free all the memory taken up by existing items; that will happen gradually as new items are stored. The most precise definition of what flush_all does is the following: it causes all items whose update time is earlier than the time at which flush_all was set to be executed to be ignored for retrieval purposes.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">“version”命令没有参数：</td><td style="font-size: 13px; line-height: 20px;" valign="top">“version” is a command with no arguments:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">version\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">在回应中，服务器发送：</td><td style="font-size: 13px; line-height: 20px;" valign="top">In response, the server sends</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">“VERSION &lt;version&gt;\r\n”</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&lt;version&gt; 是服务器的版本字串。</td><td style="font-size: 13px; line-height: 20px;" valign="top">where &lt;version&gt; is the version string for the server.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">“quit”命令没有参数：</td><td style="font-size: 13px; line-height: 20px;" valign="top">“quit” is a command with no arguments:</td></tr><tr><td style="font-size: 13px; line-height: 20px;" colspan="2" bgcolor="#cccccc" valign="top">quit\r\n</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">接收此命令后，服务器关闭连接。不过，客户端可以在不再需要时，简单地关闭连接就行，并不一定需要发送这个命令。</td><td style="font-size: 13px; line-height: 20px;" valign="top">Upon receiving this command, the server closes the connection. However, the client may also simply close the connection when it no longer needs it, without issuing this command.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td><td style="font-size: 13px; line-height: 20px;" valign="top">&nbsp;</td></tr><tr><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">UDP 协议</span></h5></td><td style="color: rgb(51, 102, 0);" valign="top"><h5><span style="font-size: 13px; line-height: 20px;">UDP protocol</span></h5></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">当来自客户端的连接数远大于TCP连接的上限时，可以使用基于UDP的接口。UDP接口不能保证传输到位，所以只有在不要求成功的操作中使用；比如被用于一个“get”请求时，会因不当的缓存处理而发生错误或回应有遗失。</td><td style="font-size: 13px; line-height: 20px;" valign="top">For very large installations where the number of clients is high enough that the number of TCP connections causes scaling difficulties, there is also a UDP-based interface. The UDP interface does not provide guaranteed delivery, so should only be used for operations that aren’t required to succeed; typically it is used for “get” requests where a missing or incomplete response can simply be treated as a cache miss.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">每个UDP数据包都包含一个简单的帧头，数据之后的内容与TCP协议的描述类似。在执行所产生的数据流中，请求必须被包含在单独的一个UDP数据包中，但是回应可能跨越多个数据包。（只有“get”和“set”请求例外，跨越了多个数据包）</td><td style="font-size: 13px; line-height: 20px;" valign="top">Each UDP datagram contains a simple frame header, followed by data in the same format as the TCP protocol described above. In the current implementation, requests must be contained in a single UDP datagram, but responses may span several datagrams. (The only common requests that would span multiple datagrams are huge multi-key “get” requests and “set” requests, both of which are more suitable to TCP transport for reliability reasons anyway.)</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">帧头有8字节长，如下（均由16位整数组成，网络字节顺序，高位在前）：</td><td style="font-size: 13px; line-height: 20px;" valign="top">The frame header is 8 bytes long, as follows (all values are 16-bit integers in network byte order, high byte first):</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top"><ul><li>0-1 请求ID</li><li>2-3 序号</li><li>4-5 该信息的数据包总数</li><li>6-7 保留位，必须为0</li></ul></td><td style="font-size: 13px; line-height: 20px;" valign="top"><ul><li>0-1 Request ID</li><li>2-3 Sequence number</li><li>4-5 Total number of datagrams in this message</li><li>6-7 Reserved for future use; must be 0</li></ul></td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">请求ID有客户端提供。一般它会是一个从随机基数开始的递增值，不过客户端想用什么样的请求ID都可以。服务器的回应会包含一个和请求中的同样的ID。客户端使用请求ID来区分每一个回应。任何一个没有请求ID的数据包，可能是之前的请求遭到延迟而造成的，应该被丢弃。</td><td style="font-size: 13px; line-height: 20px;" valign="top">The request ID is supplied by the client. Typically it will be a monotonically increasing value starting from a random seed, but the client is free to use whatever request IDs it likes. The server’s response will contain the same ID as the incoming request. The client uses the request ID to differentiate between responses to outstanding requests if there are several pending from the same server; any datagrams with an unknown request ID are probably delayed responses to an earlier request and should be discarded.</td></tr><tr><td style="font-size: 13px; line-height: 20px;" valign="top">序号的返回是从0到n-1，n是该条信息的数据包数量。</td><td style="font-size: 13px; line-height: 20px;" valign="top">The sequence number ranges from 0 to n-1, where n is the total number of datagrams in the message. The client should concatenate the payloads of the datagrams for a given response in sequence number order; the resulting byte stream will contain a complete response in the same format as the TCP protocol (including terminating \r\n sequences).</td></tr></tbody></table></div><div class="entry-tags"><strong>Tags:</strong><a href="http://sk2.com/tag/memcache/">memcache</a></div></div><ul id="flip2" class="flip"><li>Newer:<a href="http://sk2.com/post/212.html">PHP缓存技术：memcache函数详解之一</a></li><li>Older:<a href="http://sk2.com/post/210.html">DNS-劫持配置</a></li></ul></div>
<div id="footer"><div><a rel="nofollow" class="admin" href="http://sk2.com/login"><small>ADMIN</small></a><address>&copy; 2010 <a href='http://sk2.com/'>blog.sk80.com</a></address></div></div></div></div><script type="text/javascript" src="http://sk2.com/include/js/resize.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">try {var pageTracker = _gat._getTracker("UA-5695529-2");pageTracker._trackPageview();} catch(err) {}</script></body></html>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/3688801.js"></script>
<noscript><a href="http://www.51.la/?3688801" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/3688801.asp" style="border:none" /></a></noscript>