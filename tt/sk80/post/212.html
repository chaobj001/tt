<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="generator" content="blog.sk80.com" /><meta name="keywords" content="PHP缓存技术：memcache函数详解之一:PHP,memchache " /><meta name="description" content="PHP缓存技术：memcache函数详解之一,PHP缓存技术：memcache函数详解之二,Memcache 协议（中英对照）" /><meta name="author" content="4kychao" /><link rel="stylesheet" type="text/css" href="http://sk2.com/templates/default/style.css" /><title>PHP缓存技术：memcache函数详解之一</title></head><body><div id="wrapper"><div id="header"><div id="header-inner"><p class="sitename">blog.sk80.com</p><div class="description">等我有钱了, 咱买棒棒糖, 买2 根, 1 根 你看着我吃, 另1根 我吃给你看。</div><div class="menu"><ul><li class="current_page"><a rel="nofollow" href="/">日志</a></li><!--li><a href="#">About</a></li--></ul></div></div></div><div id="wrapper-inner"><p id="topic-path"><a href="/" rel="nofollow">Home</a>&gt;<a href="http://sk2.com/category/php/">PHP</a>&gt;<strong class="current">PHP缓存技术：memcache函数详解之一</strong></p><ul id="flip1" class="flip"><li class="newer"><a title="PHP缓存技术：memcache函数详解之二" href="http://sk2.com/post/213.html" rel="nofollow">Newer</a></li><li class="older"><a title="Memcache 协议（中英对照）" href="http://sk2.com/post/211.html" rel="nofollow">Older</a></li></ul><div id="detail"><div class="post"><h1>PHP缓存技术：memcache函数详解之一</h1><ul class="info"><li class="date">2010年 04月10日  18:12</li><li class="category"><a href="http://sk2.com/category/php/">PHP</a></li></ul><div class="textbody"><p>Memcache函数库是在PECL(PHP Extension Community Library)中，主要作用是搭建大容量的内存数据的临时存放区域，在分布式的时候作用体现的非常明显，否则不建议使用。<br /><strong>memcache函数所有的方法列表如下：</strong></p><p><strong>参考http://www.php.net/manual/zh/function.Memcache-add.php</strong></p><p></p><p>Memcache::add – 添加一个值，如果已经存在，则返回false</p><p>Memcache::addServer – 添加一个可供使用的服务器地址</p><p>Memcache::close – 关闭一个Memcache对象</p><p>Memcache::connect – 创建一个Memcache对象</p><p>memcache_debug – 控制调试功能</p><p>Memcache::decrement – 对保存的某个key中的值进行减法操作</p><p>Memcache::delete – 删除一个key值</p><p>Memcache::flush – 清除所有缓存的数据</p><p>Memcache::get – 获取一个key值</p><p>Memcache::getExtendedStats – 获取进程池中所有进程的运行系统统计</p><p>Memcache::getServerStatus – 获取运行服务器的参数</p><p>Memcache::getStats – 返回服务器的一些运行统计信息</p><p>Memcache::getVersion – 返回运行的Memcache的版本信息</p><p>Memcache::increment – 对保存的某个key中的值进行加法操作</p><p>Memcache::pconnect – 创建一个Memcache的持久连接对象</p><p>Memcache::replace -对一个已有的key进行覆写操作</p><p>Memcache::set – 添加一个值，如果已经存在，则覆写</p><p>Memcache::setCompressThreshold – 对大于某一大小的数据进行压缩</p><p>Memcache::setServerParams – 在运行时修改服务器的参数</p><p></p><p><strong>Memcache::add用法</strong></p><p align="left">bool <strong>Memcache::add</strong> ( string <em>$key</em> , mixed <em>$var</em> [, int <em>$flag</em> [, int <em>$expire</em> ]] )</p><p><strong>说明：</strong></p><p>如果$key不存在的时候，使用这个函数来存储$var的值。功能相同的函数是memcache_add()。</p><p></p><p><strong>参数：</strong></p><p>$key ：将要存储的键值。</p><p>$var ：存储的值，字符型和整型会按原值保存，其他类型自动序列化以后保存。</p><p>$flag：是否用<tt>MEMCACHE_COMPRESSED</tt><tt>来压缩存储的值，</tt><tt>true</tt><tt>表示压缩，</tt><tt>false</tt><tt>表示不压缩。</tt></p><p>$expire：存储值的过期时间，如果为0表示不会过期，你可以用unix时间戳或者描述来表示从现在开始的时间，但是你在使用秒数表示的时候，不要超过2592000秒 (表示30天)。</p><p></p><p><strong>返回值：</strong></p><p>如果成功则返回 TRUE，失败则返回 FALSE。如果$key值已经存在，则会返回FALSE。 其他情况下Memcache::add()的用法类似于Memcache::set()。</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>$memcache_obj&nbsp;=&nbsp;memcache_connect(“localhost”,&nbsp;11211);</p><p>/*&nbsp;面向过程API&nbsp;*/<br />memcache_add($memcache_obj,&nbsp;’var_key’,&nbsp;’test&nbsp;variable’,&nbsp;false,&nbsp;30);</p><p>/*&nbsp;面向对象API&nbsp;*/<br />$memcache_obj-&gt;add(‘var_key’,&nbsp;’test&nbsp;variable’,&nbsp;false,&nbsp;30);</p><p>?&gt;</p><p></p><p><strong>Memcache::addServer用法</strong></p><p align="left">bool <strong>Memcache::addServer</strong> ( string <em>$host</em> [, int <em>$port</em> [, bool <em>$persistent</em> [, int <em>$weight</em> [, int <em>$timeout</em> [, int <em>$retry_interval</em> [, bool <em>$status</em> [, callback <em>$failure_callback</em> ]]]]]]] )</p><p><strong>说明：</strong></p><p>添加一个可供使用的服务器地址到连接池中，连接用Memcache::addServer打开，脚本执行完后自动关闭，或者可以用Memcache::close()手动关闭。相同函数是memcache_add_server()。</p><p>当用这个方法的时候（相对于Memcache::connect()和 Memcache::pconnect()方法），网络连接只有等需要的时候才会建立，因此不会因为增加很多的服务器到连接池而增加系统负担，因为很多服务器可能没有使用。</p><p>故障恢复会发生在这个方法执行的任何阶段，只要其他的服务器是正常的，这些连接请求的失败用户不会注意到。任何一种socket或者memcached服务器级的错误可以触发故障恢复。正常的客户端错误比如增加一个存在的键值不会引发故障恢复。</p><p></p><p><strong>参数：</strong></p><p>$host服务器的地址</p><p>$port服务器端口</p><p>$persistent是否是一个持久连接</p><p>$weight这台服务器在所有服务器中所占的权重</p><p>$timeout连接的持续时间</p><p>$retry_interval连接重试的间隔时间，默认为15,设置为-1表示不进行重试</p><p>$status控制服务器的在线状态</p><p>$failure_callback允许设置一个回掉函数来处理错误信息。</p><p></p><p><strong>返回值：</strong></p><p>如果成功则返回 TRUE，失败则返回 FALSE。</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>/*&nbsp;面向对象API&nbsp;*/</p><p>$memcache&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache-&gt;addServer(‘memcache_host’,&nbsp;11211);<br />$memcache-&gt;addServer(‘memcache_host2′,&nbsp;11211);</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/</p><p>$memcache_obj&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);<br />memcache_add_server($memcache_obj,&nbsp;’memcache_host2′,&nbsp;11211);</p><p>?&gt;</p><p></p><p></p><p><strong>Memcache::close用法</strong></p><p>bool <strong>Memcache::close</strong> ( void )</p><p><strong>说明：</strong></p><p>关闭memcache服务器连接。这个函数不会关闭长连接，长连接只有在web服务器关闭或者重启的时候才会关闭。相同的函数memcache_close()</p><p></p><p><strong>返回值：</strong></p><p>如果成功则返回 TRUE，失败则返回 FALSE。</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);<br />/*&nbsp;</p><p align="left">执行一些代码..<br />*/<br />memcache_close($memcache_obj);</p><p>/*&nbsp;面向对象&nbsp;API&nbsp;*/<br />$memcache_obj&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache_obj-&gt;connect(‘memcache_host’,&nbsp;11211);<br />/*�<br />执行一些代码..<br />*/<br />$memcache_obj-&gt;close();</p><p>?&gt;</p><p></p><p></p><p><strong>Memcache::connect用法</strong></p><p align="left">bool <strong>Memcache::connect</strong> ( string <em>$host</em> [, int <em>$port</em> [, int <em>$timeout</em> ]] )</p><p></p><p><strong>说明：</strong></p><p>打开memcached服务器连接，建立一个到memcached服务器的连接，用Memcache::connect打开的连接会在脚本执行完毕后自动关闭。你也可以用Memcache::close()去关闭连接。相同的函数是memcache_connect()。</p><p></p><p><strong>参数：</strong></p><p>$host：指向memcached正在收听的链接的主机，这个参数会有另一种特殊的连接方式unix:///path/to/memcached.sock，即用unix的域名sockets，这种情况下，端口必须设置为0</p><p>$port：指向memcached正在收听的链接的端口，用unix的域名sockets的情况下，端口必须设置为0</p><p>$timeout：用于连接守护进程的秒数，当你改变默认的1秒的值的时候，你需要考虑一下，如果你的连接太慢的话，你可能会失去缓存的优势。</p><p></p><p><strong>返回值：</strong></p><p>如果成功则返回 TRUE，失败则返回 FALSE。</p><p></p><p><strong>例子：</strong></p><p align="left">&lt;?php</p><p>/*&nbsp;面向过程&nbsp;API&nbsp;*/</p><p>$memcache_obj&nbsp;=&nbsp;memcache_connect(‘memcache_host’,&nbsp;11211);</p><p>/*&nbsp;面向对象&nbsp;API&nbsp;*/</p><p>$memcache&nbsp;=&nbsp;new&nbsp;Memcache;<br />$memcache-&gt;connect(‘memcache_host’,&nbsp;11211);</p><p>?&gt;</p></div><div class="entry-tags"><strong>Tags:</strong><a href="http://sk2.com/tag/memchache/">memchache</a></div></div><ul id="flip2" class="flip"><li>Newer:<a href="http://sk2.com/post/213.html">PHP缓存技术：memcache函数详解之二</a></li><li>Older:<a href="http://sk2.com/post/211.html">Memcache 协议（中英对照）</a></li></ul></div>
<div id="footer"><div><a rel="nofollow" class="admin" href="http://sk2.com/login"><small>ADMIN</small></a><address>&copy; 2010 <a href='http://sk2.com/'>blog.sk80.com</a></address></div></div></div></div><script type="text/javascript" src="http://sk2.com/include/js/resize.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">try {var pageTracker = _gat._getTracker("UA-5695529-2");pageTracker._trackPageview();} catch(err) {}</script></body></html>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/3688801.js"></script>
<noscript><a href="http://www.51.la/?3688801" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/3688801.asp" style="border:none" /></a></noscript>